###对于web session的理解
#####1.session会话对象，生命周期伴随着浏览器关闭就清除，数据以key-value的形式存储在服务器端,用cookie来实现。session的初始化需要初始化一个32位的随机id，在将id赋给session的同时，也赋给了cookie，cookie就会将信息存储到本地计算机，实现了数据的持久化，这也就意味着一个客户端对应一个id。客户端登录的时候，如果cookie存在，会先判断cookie里面有没有sesson的header，如果有直接去cookie里面拿id，如果没有就初始化。一般在做项目的时候是没有设置session的最大生命周期的，如果没有设置的话，session自己也会有一套GC的机制来进行清理，如果设置了session的有效时间，有两种选择：等自动GC销毁，也可以主动销毁（清空值）。对session数据操作就是针对map的操作，从map中获取具体的key值信息，调用内置函数删除map中具体的key值信息，设置map中key的值。考虑到并发安全，在写的操作的时候加写锁。
#####2.在实际项目当中，session对象无法保证使用的安全性，加了一层jwt验证，调用api接口时，增加了token来验证是否具有服务器令牌，程序将用户的token存到数据库或者本地缓存。如果非法人员使用token，由于我token是由我定义的一个密钥和用户信息一起加密，我可以更新token，然后达到重新登录效果。
###解决if-else嵌套的代码问题
将串行改成并行 -- 详细见代码
###求出指定和的加数
去重复数据 -- 详细见代码
###现有一个IP库文件，格式如下(以逗号分隔)：
   
   起始ip,结束ip,国家名
   
   其中起始ip和结束ip定义了一个ip段，这个ip段中的ip都属于后面的国家名
   
   IP库文件示例如下：
   0.0.0.0,1.5.7.8,CN
   1.5.7.9,2.255.1.39,US
   2.255.1.40,5.2.255.255,CN
   …
   
#####1.为了方便处理，请实现一个函数，将ip转化为整数(已知ip格式为.分隔的4个整数，每个整数的取值范围是0-255)，并且需要保持ip之间的大小关系
全部转成二进制然后或运算 -- 详细见代码

#####2.如果使用mysql来实现从ip获取国家名的功能，mysql的表格应该如何设计？应该用怎么样的sql来查询这个表格？表格的索引应该如何设计？
首先确定国家与ip是一对一的关系；
查询利用left join左连接，一个国家能具有ip，也可能不具备，如果显示需要显示字符串拼接的形式，需要调用array函数，配合group by使用
国家表：id int
       name varchar
ip表:  id int
       country_id int (unique index)    
       ip如果量级不是很多就用varchar，如果量级多省内存的话，就用 tinyint 范围刚好是（0-255）将ip的字段做拆分（四个）
       网关，子网掩码，广播地址全部拆分 
#####3.如果使用redis来实现从ip获取国家名的功能，可以使用redis的何种数据结构？具体的实现方法是怎么样的？
因为本人没有用过redis，但是封装原生的cache,我就利用我做过的cache进行解题了。
cache的数据结构一般是利用哈希（map），以键值对存储。【ip】= country
在初始化cache之后，需要注明过期时间。更新或者赋值直接针对map进行赋值，但是取值的话，如果超过了有效时间就被GC掉了。
GC分为两种，一种是在初始化的时候就开始GC，一种是利用ticker来做定时器加个函数可以手动关闭GC的。
考虑到高并发的问题，加读写锁。
###channel 的状态(nil 打开的 关闭的 只读 只写)在哪些操作(Read Write close)下会导致 panic?
如何避免出现这些 panic  有哪些原则?
例如 channel 已经处于 close 状态，当再次 close 会导致 panic
1.在使用channel的时候进行初始化；
2.如果初始化了channel，并且申明了容量，要进行赋值；
3.对于channel一般是读写操作在关闭channel之前；
4.区分只读和只写的channel，不可以写只读 -- 编译就会报错；
5.如果声明了指定的容量，就要只赋值容量大小的数据。
###简述 Golang 常用的并发模型
我目前接触到的go的并发模型是多线程，多线程需要goroutine之间的通信工具channel，channel的功能和rabbitmq很像，就是操作不当容易造成阻塞，
先进先出的原则，一般来说先写再读不然容易造成deadlock，goroutine是异步运行，在利用go启一个协程运行函数很明显的发现输出参数的异步性，
goroutine的启动终止可以做到由程序调度，防止在程序在执行主线程时，防止结束掉子线程，需要sync.WaitGroup来收集goroutine数量，完成同步等待；
还有一种是单线程的时候可以利用runtime中的Gosched先让别的线程执行，也可以调用runtime.Goexit中止执行（不在程序中体现，程序会自动调底层）。


###这个源码文件被执行后会打印出什么内容？为什么?
#####   package main
#####   import "fmt"
#####   func main() {
#####	for i := 0; i < 10; i++ {
#####		go func() {
#####			fmt.Println(i)
#####		}()}}

什么都不会输出，只会运行主线程，子线程结束；
解决办法：调用sync.Wait堵塞主线程，直到全部输出 -- 详细见代码

### 写代码实现两个 goroutine，其中一个产生随机数并写入到 go channel 中，另外一个从 channel 中读取数字并打印到标准输出。最终输出五个随机数。
思路：一个channel就可以实现，需要利用sync.Group进行任务调度，安排好顺序，先写好然后关掉，再先进先出 -- 详细见代码